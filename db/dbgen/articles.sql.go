// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: articles.sql

package dbgen

import (
	"context"
	"time"
)

const countArticlesByJob = `-- name: CountArticlesByJob :one
SELECT COUNT(*) FROM articles WHERE job_id = ? AND user_id = ?
`

type CountArticlesByJobParams struct {
	JobID  int64 `json:"job_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) CountArticlesByJob(ctx context.Context, arg CountArticlesByJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countArticlesByJob, arg.JobID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countArticlesByUser = `-- name: CountArticlesByUser :one
SELECT COUNT(*) as count FROM articles WHERE user_id = ?
`

func (q *Queries) CountArticlesByUser(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countArticlesByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countArticlesByUserDateRange = `-- name: CountArticlesByUserDateRange :one
SELECT COUNT(*) as count FROM articles WHERE user_id = ? AND retrieved_at >= ? AND retrieved_at <= ?
`

type CountArticlesByUserDateRangeParams struct {
	UserID        int64     `json:"user_id"`
	RetrievedAt   time.Time `json:"retrieved_at"`
	RetrievedAt_2 time.Time `json:"retrieved_at_2"`
}

func (q *Queries) CountArticlesByUserDateRange(ctx context.Context, arg CountArticlesByUserDateRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countArticlesByUserDateRange, arg.UserID, arg.RetrievedAt, arg.RetrievedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countArticlesByUserSince = `-- name: CountArticlesByUserSince :one
SELECT COUNT(*) as count FROM articles WHERE user_id = ? AND retrieved_at >= ?
`

type CountArticlesByUserSinceParams struct {
	UserID      int64     `json:"user_id"`
	RetrievedAt time.Time `json:"retrieved_at"`
}

func (q *Queries) CountArticlesByUserSince(ctx context.Context, arg CountArticlesByUserSinceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countArticlesByUserSince, arg.UserID, arg.RetrievedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchArticlesByUser = `-- name: CountSearchArticlesByUser :one
SELECT COUNT(*) FROM articles 
WHERE user_id = ? AND (title LIKE ? OR summary LIKE ?)
`

type CountSearchArticlesByUserParams struct {
	UserID  int64  `json:"user_id"`
	Title   string `json:"title"`
	Summary string `json:"summary"`
}

func (q *Queries) CountSearchArticlesByUser(ctx context.Context, arg CountSearchArticlesByUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchArticlesByUser, arg.UserID, arg.Title, arg.Summary)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (job_id, user_id, title, url, summary, content_path, retrieved_at)
VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
RETURNING id, job_id, user_id, title, url, summary, content_path, retrieved_at
`

type CreateArticleParams struct {
	JobID       int64  `json:"job_id"`
	UserID      int64  `json:"user_id"`
	Title       string `json:"title"`
	Url         string `json:"url"`
	Summary     string `json:"summary"`
	ContentPath string `json:"content_path"`
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.JobID,
		arg.UserID,
		arg.Title,
		arg.Url,
		arg.Summary,
		arg.ContentPath,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.UserID,
		&i.Title,
		&i.Url,
		&i.Summary,
		&i.ContentPath,
		&i.RetrievedAt,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM articles WHERE id = ? AND user_id = ?
`

type DeleteArticleParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteArticle(ctx context.Context, arg DeleteArticleParams) error {
	_, err := q.db.ExecContext(ctx, deleteArticle, arg.ID, arg.UserID)
	return err
}

const getArticle = `-- name: GetArticle :one
SELECT id, job_id, user_id, title, url, summary, content_path, retrieved_at FROM articles WHERE id = ? AND user_id = ?
`

type GetArticleParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetArticle(ctx context.Context, arg GetArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, getArticle, arg.ID, arg.UserID)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.UserID,
		&i.Title,
		&i.Url,
		&i.Summary,
		&i.ContentPath,
		&i.RetrievedAt,
	)
	return i, err
}

const listArticlesByJob = `-- name: ListArticlesByJob :many
SELECT id, job_id, user_id, title, url, summary, content_path, retrieved_at FROM articles WHERE job_id = ? ORDER BY retrieved_at DESC
`

func (q *Queries) ListArticlesByJob(ctx context.Context, jobID int64) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesByJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Summary,
			&i.ContentPath,
			&i.RetrievedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByJobPaginated = `-- name: ListArticlesByJobPaginated :many
SELECT id, job_id, user_id, title, url, summary, content_path, retrieved_at FROM articles WHERE job_id = ? AND user_id = ? ORDER BY retrieved_at DESC LIMIT ? OFFSET ?
`

type ListArticlesByJobPaginatedParams struct {
	JobID  int64 `json:"job_id"`
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListArticlesByJobPaginated(ctx context.Context, arg ListArticlesByJobPaginatedParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesByJobPaginated,
		arg.JobID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Summary,
			&i.ContentPath,
			&i.RetrievedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByUser = `-- name: ListArticlesByUser :many
SELECT id, job_id, user_id, title, url, summary, content_path, retrieved_at FROM articles WHERE user_id = ? ORDER BY retrieved_at DESC LIMIT ? OFFSET ?
`

type ListArticlesByUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListArticlesByUser(ctx context.Context, arg ListArticlesByUserParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Summary,
			&i.ContentPath,
			&i.RetrievedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByUserDateRange = `-- name: ListArticlesByUserDateRange :many
SELECT id, job_id, user_id, title, url, summary, content_path, retrieved_at FROM articles WHERE user_id = ? AND retrieved_at >= ? AND retrieved_at <= ? ORDER BY retrieved_at DESC LIMIT ? OFFSET ?
`

type ListArticlesByUserDateRangeParams struct {
	UserID        int64     `json:"user_id"`
	RetrievedAt   time.Time `json:"retrieved_at"`
	RetrievedAt_2 time.Time `json:"retrieved_at_2"`
	Limit         int64     `json:"limit"`
	Offset        int64     `json:"offset"`
}

func (q *Queries) ListArticlesByUserDateRange(ctx context.Context, arg ListArticlesByUserDateRangeParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesByUserDateRange,
		arg.UserID,
		arg.RetrievedAt,
		arg.RetrievedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Summary,
			&i.ContentPath,
			&i.RetrievedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByUserSince = `-- name: ListArticlesByUserSince :many
SELECT id, job_id, user_id, title, url, summary, content_path, retrieved_at FROM articles WHERE user_id = ? AND retrieved_at >= ? ORDER BY retrieved_at DESC LIMIT ? OFFSET ?
`

type ListArticlesByUserSinceParams struct {
	UserID      int64     `json:"user_id"`
	RetrievedAt time.Time `json:"retrieved_at"`
	Limit       int64     `json:"limit"`
	Offset      int64     `json:"offset"`
}

func (q *Queries) ListArticlesByUserSince(ctx context.Context, arg ListArticlesByUserSinceParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesByUserSince,
		arg.UserID,
		arg.RetrievedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Summary,
			&i.ContentPath,
			&i.RetrievedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchArticlesByUser = `-- name: SearchArticlesByUser :many
SELECT id, job_id, user_id, title, url, summary, content_path, retrieved_at FROM articles 
WHERE user_id = ? AND (title LIKE ? OR summary LIKE ?)
ORDER BY retrieved_at DESC LIMIT ? OFFSET ?
`

type SearchArticlesByUserParams struct {
	UserID  int64  `json:"user_id"`
	Title   string `json:"title"`
	Summary string `json:"summary"`
	Limit   int64  `json:"limit"`
	Offset  int64  `json:"offset"`
}

func (q *Queries) SearchArticlesByUser(ctx context.Context, arg SearchArticlesByUserParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, searchArticlesByUser,
		arg.UserID,
		arg.Title,
		arg.Summary,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.UserID,
			&i.Title,
			&i.Url,
			&i.Summary,
			&i.ContentPath,
			&i.RetrievedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
