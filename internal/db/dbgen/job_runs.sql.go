// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: job_runs.sql

package dbgen

import (
	"context"
	"time"
)

const cancelJobRun = `-- name: CancelJobRun :exec
UPDATE job_runs
SET status = 'cancelled', error_message = 'Cancelled by user', completed_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) CancelJobRun(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, cancelJobRun, id)
	return err
}

const cancelOrphanedRuns = `-- name: CancelOrphanedRuns :exec
UPDATE job_runs 
SET status = 'cancelled', error_message = 'Cancelled: new run started', completed_at = CURRENT_TIMESTAMP 
WHERE job_id = ? AND status = 'running'
`

func (q *Queries) CancelOrphanedRuns(ctx context.Context, jobID int64) error {
	_, err := q.db.ExecContext(ctx, cancelOrphanedRuns, jobID)
	return err
}

const completeJobRun = `-- name: CompleteJobRun :exec
UPDATE job_runs
SET status = ?, error_message = ?, articles_saved = ?, duplicates_skipped = ?, completed_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type CompleteJobRunParams struct {
	Status            string  `json:"status"`
	ErrorMessage      *string `json:"error_message"`
	ArticlesSaved     *int64  `json:"articles_saved"`
	DuplicatesSkipped *int64  `json:"duplicates_skipped"`
	ID                int64   `json:"id"`
}

func (q *Queries) CompleteJobRun(ctx context.Context, arg CompleteJobRunParams) error {
	_, err := q.db.ExecContext(ctx, completeJobRun,
		arg.Status,
		arg.ErrorMessage,
		arg.ArticlesSaved,
		arg.DuplicatesSkipped,
		arg.ID,
	)
	return err
}

const createJobRun = `-- name: CreateJobRun :one
INSERT INTO job_runs (job_id, status, started_at)
VALUES (?, 'running', CURRENT_TIMESTAMP)
RETURNING id, job_id, status, error_message, started_at, completed_at, articles_saved, duplicates_skipped, log_path
`

func (q *Queries) CreateJobRun(ctx context.Context, jobID int64) (JobRun, error) {
	row := q.db.QueryRowContext(ctx, createJobRun, jobID)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ArticlesSaved,
		&i.DuplicatesSkipped,
		&i.LogPath,
	)
	return i, err
}

const getJobRun = `-- name: GetJobRun :one
SELECT jr.id, jr.job_id, jr.status, jr.error_message, jr.started_at, jr.completed_at, jr.articles_saved, jr.duplicates_skipped, jr.log_path, j.name as job_name, j.user_id as job_user_id
FROM job_runs jr
JOIN jobs j ON jr.job_id = j.id
WHERE jr.id = ? AND j.user_id = ?
`

type GetJobRunParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

type GetJobRunRow struct {
	ID                int64      `json:"id"`
	JobID             int64      `json:"job_id"`
	Status            string     `json:"status"`
	ErrorMessage      *string    `json:"error_message"`
	StartedAt         time.Time  `json:"started_at"`
	CompletedAt       *time.Time `json:"completed_at"`
	ArticlesSaved     *int64     `json:"articles_saved"`
	DuplicatesSkipped *int64     `json:"duplicates_skipped"`
	LogPath           string     `json:"log_path"`
	JobName           string     `json:"job_name"`
	JobUserID         int64      `json:"job_user_id"`
}

func (q *Queries) GetJobRun(ctx context.Context, arg GetJobRunParams) (GetJobRunRow, error) {
	row := q.db.QueryRowContext(ctx, getJobRun, arg.ID, arg.UserID)
	var i GetJobRunRow
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ArticlesSaved,
		&i.DuplicatesSkipped,
		&i.LogPath,
		&i.JobName,
		&i.JobUserID,
	)
	return i, err
}

const getJobRunLogPath = `-- name: GetJobRunLogPath :one
SELECT log_path FROM job_runs jr
JOIN jobs j ON jr.job_id = j.id
WHERE jr.id = ? AND j.user_id = ?
`

type GetJobRunLogPathParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetJobRunLogPath(ctx context.Context, arg GetJobRunLogPathParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getJobRunLogPath, arg.ID, arg.UserID)
	var log_path string
	err := row.Scan(&log_path)
	return log_path, err
}

const listJobRunsByJob = `-- name: ListJobRunsByJob :many
SELECT id, job_id, status, error_message, started_at, completed_at, articles_saved, duplicates_skipped, log_path FROM job_runs WHERE job_id = ? ORDER BY started_at DESC LIMIT 10
`

func (q *Queries) ListJobRunsByJob(ctx context.Context, jobID int64) ([]JobRun, error) {
	rows, err := q.db.QueryContext(ctx, listJobRunsByJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobRun{}
	for rows.Next() {
		var i JobRun
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ArticlesSaved,
			&i.DuplicatesSkipped,
			&i.LogPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentJobRuns = `-- name: ListRecentJobRuns :many
SELECT jr.id, jr.job_id, jr.status, jr.error_message, jr.started_at, jr.completed_at, jr.articles_saved, jr.duplicates_skipped, jr.log_path, j.name as job_name, j.user_id as job_user_id
FROM job_runs jr
JOIN jobs j ON jr.job_id = j.id
WHERE j.user_id = ?
ORDER BY jr.started_at DESC
LIMIT ?
`

type ListRecentJobRunsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
}

type ListRecentJobRunsRow struct {
	ID                int64      `json:"id"`
	JobID             int64      `json:"job_id"`
	Status            string     `json:"status"`
	ErrorMessage      *string    `json:"error_message"`
	StartedAt         time.Time  `json:"started_at"`
	CompletedAt       *time.Time `json:"completed_at"`
	ArticlesSaved     *int64     `json:"articles_saved"`
	DuplicatesSkipped *int64     `json:"duplicates_skipped"`
	LogPath           string     `json:"log_path"`
	JobName           string     `json:"job_name"`
	JobUserID         int64      `json:"job_user_id"`
}

func (q *Queries) ListRecentJobRuns(ctx context.Context, arg ListRecentJobRunsParams) ([]ListRecentJobRunsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentJobRuns, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentJobRunsRow{}
	for rows.Next() {
		var i ListRecentJobRunsRow
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ArticlesSaved,
			&i.DuplicatesSkipped,
			&i.LogPath,
			&i.JobName,
			&i.JobUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRunningJobRuns = `-- name: ListRunningJobRuns :many
SELECT jr.id, jr.job_id, jr.status, jr.error_message, jr.started_at, jr.completed_at, jr.articles_saved, jr.duplicates_skipped, jr.log_path, j.name as job_name, j.user_id as job_user_id
FROM job_runs jr
JOIN jobs j ON jr.job_id = j.id
WHERE jr.status = 'running' AND j.user_id = ?
ORDER BY jr.started_at DESC
`

type ListRunningJobRunsRow struct {
	ID                int64      `json:"id"`
	JobID             int64      `json:"job_id"`
	Status            string     `json:"status"`
	ErrorMessage      *string    `json:"error_message"`
	StartedAt         time.Time  `json:"started_at"`
	CompletedAt       *time.Time `json:"completed_at"`
	ArticlesSaved     *int64     `json:"articles_saved"`
	DuplicatesSkipped *int64     `json:"duplicates_skipped"`
	LogPath           string     `json:"log_path"`
	JobName           string     `json:"job_name"`
	JobUserID         int64      `json:"job_user_id"`
}

func (q *Queries) ListRunningJobRuns(ctx context.Context, userID int64) ([]ListRunningJobRunsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRunningJobRuns, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRunningJobRunsRow{}
	for rows.Next() {
		var i ListRunningJobRunsRow
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ArticlesSaved,
			&i.DuplicatesSkipped,
			&i.LogPath,
			&i.JobName,
			&i.JobUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobRunComplete = `-- name: UpdateJobRunComplete :exec
UPDATE job_runs
SET status = ?, error_message = ?, articles_saved = ?, duplicates_skipped = ?, completed_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateJobRunCompleteParams struct {
	Status            string  `json:"status"`
	ErrorMessage      *string `json:"error_message"`
	ArticlesSaved     *int64  `json:"articles_saved"`
	DuplicatesSkipped *int64  `json:"duplicates_skipped"`
	ID                int64   `json:"id"`
}

func (q *Queries) UpdateJobRunComplete(ctx context.Context, arg UpdateJobRunCompleteParams) error {
	_, err := q.db.ExecContext(ctx, updateJobRunComplete,
		arg.Status,
		arg.ErrorMessage,
		arg.ArticlesSaved,
		arg.DuplicatesSkipped,
		arg.ID,
	)
	return err
}

const updateJobRunLogPath = `-- name: UpdateJobRunLogPath :exec
UPDATE job_runs SET log_path = ? WHERE id = ?
`

type UpdateJobRunLogPathParams struct {
	LogPath string `json:"log_path"`
	ID      int64  `json:"id"`
}

func (q *Queries) UpdateJobRunLogPath(ctx context.Context, arg UpdateJobRunLogPathParams) error {
	_, err := q.db.ExecContext(ctx, updateJobRunLogPath, arg.LogPath, arg.ID)
	return err
}
